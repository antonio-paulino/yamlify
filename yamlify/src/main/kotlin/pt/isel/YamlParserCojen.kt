package pt.isel

import org.cojen.maker.ClassMaker
import org.cojen.maker.MethodMaker
import org.cojen.maker.Variable
import java.lang.reflect.Parameter
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type
import java.lang.reflect.WildcardType
import kotlin.reflect.KClass
import kotlin.jvm.*
import kotlin.reflect.full.primaryConstructor
import kotlin.reflect.jvm.javaConstructor

/**
 * A YamlParser that uses Cojen Maker to generate a parser.
 */
open class YamlParserCojen<T : Any>(
    private val type: Class<T>,
    private val nrOfInitArgs: Int)
: AbstractYamlParser<T>(type.kotlin) {

    companion object {

        private val yamlParsers: MutableMap<String, YamlParserCojen<*>> = mutableMapOf()

        private fun parserName(type: KClass<*>, nrOfInitArgs: Int): String {
            return "${type.simpleName}Parser$nrOfInitArgs"
        }
        /**
         * Creates a YamlParser for the given type using Cojen Maker if it does not already exist.
         * Keep it in an internal cache.
         */
        fun <T : Any> yamlParser(type: KClass<T>, nrOfInitArgs: Int = type.constructors.first().parameters.size): AbstractYamlParser<T> {
            return yamlParsers.getOrPut(parserName(type, nrOfInitArgs)) {
                YamlParserCojen(type.java, nrOfInitArgs)
                    .buildYamlParser()
                    .finish()
                    .getConstructor(Class::class.java, Integer::class.java)
                    .newInstance(type.java, nrOfInitArgs) as YamlParserCojen<*>
            } as YamlParserCojen<T>
        }
    }
    /**
     * Used to get a parser for other Type using the same parsing approach.
     */
    override fun <T : Any> yamlParser(type: KClass<T>) = YamlParserCojen.yamlParser(type)

    /**
     * Do not change this method in YamlParserCojen.
     */
    override fun newInstance(args: Map<String, Any>): T {
        throw UnsupportedOperationException("This method is overridden in a subclass dynamically generated by buildYamlParser() function!")
    }

    private fun buildYamlParser() : ClassMaker {
        TODO()
    }

    // Used to get a new dynamic parser for a type
    // Called by dynamically generated parsers
    fun javaYamlParser(type: Class<T>, nrOfInitArgs: Int): YamlParserCojen<T> {
        return yamlParser(type.kotlin, nrOfInitArgs) as YamlParserCojen<T>
    }

    private fun buildNewInstanceMethod(newInstance: MethodMaker, type: KClass<*>, nrOfInitArgs: Int) {

        if (nrOfInitArgs == 0) {
            val arg = newInstance.param(0).invoke("values").invoke("iterator").invoke("next")
            val value = castType(newInstance, arg, type.java)
            newInstance.return_(value)
            return
        }

        val args = newInstance.param(0).cast(Map::class.java)

        val constructor = type.java.constructors.first { it.parameters.size == nrOfInitArgs }

        val props = constructor.parameters.map { it ->

                val name = newInstance.`var`(String::class.java).set(it.name)

                if (it.annotations.any { it is YamlArg }) {
                    val defaultProp = args.invoke("get", it.name)
                    val annotation = it.annotations.first { it is YamlArg } as YamlArg
                    defaultProp.ifEq(null) {
                        name.set(annotation.yamlName)
                    }
                    defaultProp.ifEq(null) {
                        args.invoke("get", annotation.yamlName).ifNe(null) {
                            newInstance.new_(IllegalArgumentException::class.java, "Duplicate parameter: ${it.name}")
                                .throw_()
                        }
                    }
                }

                val value = args.invoke("get", name)

                if (!it.hasDefaultValue(type.java as Class<T>)) {
                    value.ifEq(null) {
                        newInstance.new_(IllegalArgumentException::class.java, "Missing parameter: ${it.name}")
                            .throw_()
                    }
                }

                if (it.annotations.any { it is YamlConvert }) {
                    val ret = newInstance.`var`(it.type).set(null)
                    value.ifNe(null) {
                        val annotation = it.annotations.first { it is YamlConvert } as YamlConvert
                        val obj = newInstance.new_(annotation.parser.java)
                        ret.set(obj.invoke("convertToObject", value.invoke("toString")))
                    }
                    ret
                }
                else {
                    if (it.type == List::class.java) {
                        val ret : Variable = newInstance.new_(ArrayList::class.java)
                        value.ifNe(null) {
                           ret.set(castToIterable(newInstance, args.invoke("get", name), it.parameterizedType as ParameterizedType))
                        }
                        ret
                    }
                    else {
                        castType(newInstance, value, it.type)
                    }
                }
            }.toTypedArray()

        val instance = newInstance.new_(type.java, *props)

        newInstance.return_(instance)

    }

    private fun Parameter.hasDefaultValue(type: Class<T>) : Boolean {
        val constructor = type.kotlin.primaryConstructor!!.javaConstructor!!
        val position = constructor.parameters.indexOfFirst {
            it.type == this.type && it.type.name == this.type.name
        } + 1
        return !type.constructors.all {
            it.parameters.any { (it.name == this.name || it.name == "arg$position") }
        }
    }

    private fun castToIterable(newInstance: MethodMaker, value: Variable, type: Type): Variable? {

        // Create a new list and set the type of the list
        // e.g.: List<String>
        val list = newInstance.`var`(List::class.java)
            .set(value.cast(List::class.java))

        // Create a new instance of the list
        val retList = newInstance.new_(ArrayList::class.java)

        // check if the type is a wildcard type (e.g.: List<?>)
        if (type is WildcardType) {
            // get the type of the list
            // e.g.: String in a List<String>
            val paramType = type.upperBounds[0]
            list.forEach(newInstance) { prop ->
                // create a new list (referring to the list of the list)
                val item = newInstance.new_(ArrayList::class.java)
                item.invoke("add", prop)
                val newList = newInstance.new_(ArrayList::class.java, castToIterable(newInstance, item, paramType))
                retList.invoke("add", newList.invoke("get", 0))
            }
            return retList
        }

        val paramType = (type as ParameterizedType).actualTypeArguments[0]

        if (paramType is List<*> || paramType is WildcardType) {
            list.forEach(newInstance) { prop ->
                retList.invoke("add", castToIterable(newInstance, prop, paramType))
            }
        }
        else {
            list.forEach(newInstance) { prop ->
                val newMap = prop.cast(LinkedHashMap::class.java)
                if (isSimpleType(paramType)) {
                    // get the value of the map (e.g.: "value" in {key: "value"})
                    // because it is a simple type, doesn't make sense to be a map
                    val item = newMap.invoke("values").invoke("iterator").invoke("next")
                    retList.invoke("add", castType(newInstance, item, paramType))
                } else {
                    retList.invoke("add", castType(newInstance, newMap, paramType))
                }
            }
        }
        return retList
    }

    private fun Variable.forEach(newInstance: MethodMaker, block: (Variable) -> Unit) {
        val size = this.invoke("size") // list size
        val i = newInstance.`var`(Int::class.java).set(0) // index
        val start = newInstance.label().here() // asm like label
        // call the block with the value of the list at the index i
        block(this.invoke("get", i))
        i.inc(1)
        i.ifLt(size) {
            newInstance.goto_(start)
        }
    }

    private fun castType(newInstance: MethodMaker, value: Variable, type: Type): Any? {
        TODO()
    }

    private fun isSimpleType(type: Type): Boolean {
        // check if it is a primitive type
        if ((type as Class<*>).isPrimitive) {
            return true
        }
        // check if it is a boxed primitive type
        return when (type) {
            String::class.java -> return true
            Integer::class.java -> return true
            UByte::class.java -> return true
            UShort::class.java -> return true
            UInt::class.java -> return true
            ULong::class.java -> return true
            else -> false
        }
    }


}


